// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// WARNING! Do not edit this file manually, your changes will be overwritten.

#include "MultipleQueriesClient.h"

#include "graphqlservice/internal/SortedMap.h"

#include <algorithm>
#include <array>
#include <cstddef>
#include <stdexcept>
#include <string_view>
#include <utility>

using namespace std::literals;

namespace graphql {
namespace multiple {
namespace client {

const std::string& GetRequestText() noexcept
{
	static const auto s_request = R"gql(
		# Copyright (c) Microsoft Corporation. All rights reserved.
		# Licensed under the MIT License.
		
		query Appointments {
		  appointments {
		    edges {
		      node {
		        id
		        subject
		        when
		        isNow
		        __typename
		      }
		    }
		  }
		}
		
		query Tasks {
		  tasks {
		    edges {
		      node {
		        id
		        title
		        isComplete
		        __typename
		      }
		    }
		  }
		}
		
		query UnreadCounts {
		  unreadCounts {
		    edges {
		      node {
		        id
		        name
		        unreadCount
		        __typename
		      }
		    }
		  }
		}
		
		query Miscellaneous {
		  # Read a field with an enum type
		  testTaskState
		
		  # Try a field with a union type
		  anyType(ids: ["ZmFrZVRhc2tJZA=="]) {
		    __typename
		    ...on Node {
		      id
		    }
		    ...on Task {
		      id
		      title
		      isComplete
		    }
		    ...on Appointment {
		      id
		      subject
		      when
		      isNow
		    }
		  }
		
		  # Try a field with a C++ keyword
		  default
		}
		
		mutation CompleteTaskMutation($input: CompleteTaskInput = {id: "ZmFrZVRhc2tJZA==", isComplete: true, clientMutationId: "Hi There!"}, $skipClientMutationId: Boolean!) {
		  completedTask: completeTask(input: $input) {
		    completedTask: task {
		      completedTaskId: id
		      title
		      isComplete
		    }
		    clientMutationId @skip(if: $skipClientMutationId)
		  }
		}
	)gql"s;

	return s_request;
}

const peg::ast& GetRequestObject() noexcept
{
	static const auto s_request = []() noexcept {
		auto ast = peg::parseString(GetRequestText());

		// This has already been validated against the schema by clientgen.
		ast.validated = true;

		return ast;
	}();

	return s_request;
}

} // namespace client

using namespace graphql::client;

CompleteTaskInput::CompleteTaskInput() noexcept
	: id {}
	, testTaskState {}
	, isComplete {}
	, clientMutationId {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

CompleteTaskInput::CompleteTaskInput(
		response::IdType idArg,
		std::optional<TaskState> testTaskStateArg,
		std::optional<bool> isCompleteArg,
		std::optional<std::string> clientMutationIdArg) noexcept
	: id { std::move(idArg) }
	, testTaskState { std::move(testTaskStateArg) }
	, isComplete { std::move(isCompleteArg) }
	, clientMutationId { std::move(clientMutationIdArg) }
{
}

CompleteTaskInput::CompleteTaskInput(const CompleteTaskInput& other)
	: id { ModifiedVariable<response::IdType>::duplicate(other.id) }
	, testTaskState { ModifiedVariable<TaskState>::duplicate<TypeModifier::Nullable>(other.testTaskState) }
	, isComplete { ModifiedVariable<bool>::duplicate<TypeModifier::Nullable>(other.isComplete) }
	, clientMutationId { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.clientMutationId) }
{
}

CompleteTaskInput::CompleteTaskInput(CompleteTaskInput&& other) noexcept
	: id { std::move(other.id) }
	, testTaskState { std::move(other.testTaskState) }
	, isComplete { std::move(other.isComplete) }
	, clientMutationId { std::move(other.clientMutationId) }
{
}

CompleteTaskInput::~CompleteTaskInput()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

CompleteTaskInput& CompleteTaskInput::operator=(const CompleteTaskInput& other)
{
	return *this = CompleteTaskInput { other };
}

CompleteTaskInput& CompleteTaskInput::operator=(CompleteTaskInput&& other) noexcept
{
	id = std::move(other.id);
	testTaskState = std::move(other.testTaskState);
	isComplete = std::move(other.isComplete);
	clientMutationId = std::move(other.clientMutationId);

	return *this;
}

} // namespace multiple
namespace client {

using namespace multiple;

template <>
graphql::multiple::client::query::Appointments::Response::appointments_AppointmentConnection::edges_AppointmentEdge::node_Appointment Response<graphql::multiple::client::query::Appointments::Response::appointments_AppointmentConnection::edges_AppointmentEdge::node_Appointment>::parse(response::Value&& response)
{
	graphql::multiple::client::query::Appointments::Response::appointments_AppointmentConnection::edges_AppointmentEdge::node_Appointment result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(id)js"sv)
			{
				result.id = ModifiedResponse<response::IdType>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(subject)js"sv)
			{
				result.subject = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
			if (member.first == R"js(when)js"sv)
			{
				result.when = ModifiedResponse<response::Value>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
			if (member.first == R"js(isNow)js"sv)
			{
				result.isNow = ModifiedResponse<bool>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(__typename)js"sv)
			{
				result._typename = ModifiedResponse<std::string>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
graphql::multiple::client::query::Appointments::Response::appointments_AppointmentConnection::edges_AppointmentEdge Response<graphql::multiple::client::query::Appointments::Response::appointments_AppointmentConnection::edges_AppointmentEdge>::parse(response::Value&& response)
{
	graphql::multiple::client::query::Appointments::Response::appointments_AppointmentConnection::edges_AppointmentEdge result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(node)js"sv)
			{
				result.node = ModifiedResponse<graphql::multiple::client::query::Appointments::Response::appointments_AppointmentConnection::edges_AppointmentEdge::node_Appointment>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
graphql::multiple::client::query::Appointments::Response::appointments_AppointmentConnection Response<graphql::multiple::client::query::Appointments::Response::appointments_AppointmentConnection>::parse(response::Value&& response)
{
	graphql::multiple::client::query::Appointments::Response::appointments_AppointmentConnection result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(edges)js"sv)
			{
				result.edges = ModifiedResponse<graphql::multiple::client::query::Appointments::Response::appointments_AppointmentConnection::edges_AppointmentEdge>::parse<TypeModifier::Nullable, TypeModifier::List, TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

} // namespace client

namespace multiple::client::query::Appointments {

const std::string& GetOperationName() noexcept
{
	static const auto s_name = R"gql(Appointments)gql"s;

	return s_name;
}

struct ResponseVisitor::impl
{
	enum class VisitorState
	{
		Start,
		Member_appointments,
		Member_appointments_edges,
		Member_appointments_edges_0,
		Member_appointments_edges_0_,
		Member_appointments_edges_0_node,
		Member_appointments_edges_0_node_id,
		Member_appointments_edges_0_node_subject,
		Member_appointments_edges_0_node_when,
		Member_appointments_edges_0_node_isNow,
		Member_appointments_edges_0_node__typename,
		Complete,
	};

	VisitorState state { VisitorState::Start };
	Response response {};
};

ResponseVisitor::ResponseVisitor() noexcept
	: _pimpl { std::make_unique<impl>() }
{
}

ResponseVisitor::~ResponseVisitor()
{
}

void ResponseVisitor::add_value([[maybe_unused]] std::shared_ptr<const response::Value>&& value)
{
	using namespace graphql::client;

	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_appointments:
			_pimpl->state = impl::VisitorState::Start;
			_pimpl->response.appointments = ModifiedResponse<Response::appointments_AppointmentConnection>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_appointments_edges_0:
			_pimpl->response.appointments.edges->push_back(ModifiedResponse<Response::appointments_AppointmentConnection::edges_AppointmentEdge>::parse<TypeModifier::Nullable>(response::Value { *value }));
			break;

		case impl::VisitorState::Member_appointments_edges_0_node:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_;
			_pimpl->response.appointments.edges->back()->node = ModifiedResponse<Response::appointments_AppointmentConnection::edges_AppointmentEdge::node_Appointment>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		case impl::VisitorState::Member_appointments_edges_0_node_id:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node;
			_pimpl->response.appointments.edges->back()->node->id = ModifiedResponse<response::IdType>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_appointments_edges_0_node_subject:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node;
			_pimpl->response.appointments.edges->back()->node->subject = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		case impl::VisitorState::Member_appointments_edges_0_node_when:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node;
			_pimpl->response.appointments.edges->back()->node->when = ModifiedResponse<response::Value>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		case impl::VisitorState::Member_appointments_edges_0_node_isNow:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node;
			_pimpl->response.appointments.edges->back()->node->isNow = ModifiedResponse<bool>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_appointments_edges_0_node__typename:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node;
			_pimpl->response.appointments.edges->back()->node->_typename = ModifiedResponse<std::string>::parse(response::Value { *value });
			break;

		default:
			break;
	}
}

void ResponseVisitor::reserve([[maybe_unused]] std::size_t count)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_appointments_edges_0:
			_pimpl->response.appointments.edges->reserve(count);
			break;

		default:
			break;
	}
}

void ResponseVisitor::start_object()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_appointments_edges_0:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_;
			_pimpl->response.appointments.edges->push_back(std::make_optional<Response::appointments_AppointmentConnection::edges_AppointmentEdge>({}));
			break;

		case impl::VisitorState::Member_appointments_edges_0_node:
			_pimpl->response.appointments.edges->back()->node = std::make_optional<Response::appointments_AppointmentConnection::edges_AppointmentEdge::node_Appointment>({});
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_member([[maybe_unused]] std::string&& key)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Start:
			if (key == "appointments"sv)
			{
				_pimpl->state = impl::VisitorState::Member_appointments;
			}
			break;

		case impl::VisitorState::Member_appointments:
			if (key == "edges"sv)
			{
				_pimpl->state = impl::VisitorState::Member_appointments_edges;
			}
			break;

		case impl::VisitorState::Member_appointments_edges_0_:
			if (key == "node"sv)
			{
				_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node;
			}
			break;

		case impl::VisitorState::Member_appointments_edges_0_node:
			if (key == "id"sv)
			{
				_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node_id;
			}
			else if (key == "subject"sv)
			{
				_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node_subject;
			}
			else if (key == "when"sv)
			{
				_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node_when;
			}
			else if (key == "isNow"sv)
			{
				_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node_isNow;
			}
			else if (key == "__typename"sv)
			{
				_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node__typename;
			}
			break;

		default:
			break;
	}
}

void ResponseVisitor::end_object()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_appointments_edges_0_node:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_;
			break;

		case impl::VisitorState::Member_appointments_edges_0_:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0;
			break;

		case impl::VisitorState::Member_appointments:
			_pimpl->state = impl::VisitorState::Start;
			break;

		default:
			break;
	}
}

void ResponseVisitor::start_array()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_appointments_edges:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0;
			_pimpl->response.appointments.edges = std::make_optional<std::vector<std::optional<Response::appointments_AppointmentConnection::edges_AppointmentEdge>>>({});
			break;

		default:
			break;
	}
}

void ResponseVisitor::end_array()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_appointments_edges_0:
			_pimpl->state = impl::VisitorState::Member_appointments;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_null()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_appointments_edges_0:
			_pimpl->response.appointments.edges->push_back(std::nullopt);
			break;

		case impl::VisitorState::Member_appointments_edges_0_node:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_;
			_pimpl->response.appointments.edges->back()->node = std::nullopt;
			break;

		case impl::VisitorState::Member_appointments_edges_0_node_subject:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node;
			_pimpl->response.appointments.edges->back()->node->subject = std::nullopt;
			break;

		case impl::VisitorState::Member_appointments_edges_0_node_when:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node;
			_pimpl->response.appointments.edges->back()->node->when = std::nullopt;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_string([[maybe_unused]] std::string&& value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_appointments_edges_0_node_subject:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node;
			_pimpl->response.appointments.edges->back()->node->subject = std::move(value);
			break;

		case impl::VisitorState::Member_appointments_edges_0_node__typename:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node;
			_pimpl->response.appointments.edges->back()->node->_typename = std::move(value);
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_enum([[maybe_unused]] std::string&& value)
{
	using namespace graphql::client;

	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_id([[maybe_unused]] response::IdType&& value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_appointments_edges_0_node_id:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node;
			_pimpl->response.appointments.edges->back()->node->id = std::move(value);
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_bool([[maybe_unused]] bool value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_appointments_edges_0_node_isNow:
			_pimpl->state = impl::VisitorState::Member_appointments_edges_0_node;
			_pimpl->response.appointments.edges->back()->node->isNow = value;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_int([[maybe_unused]] int value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_float([[maybe_unused]] double value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::complete()
{
	_pimpl->state = impl::VisitorState::Complete;
}

Response ResponseVisitor::response()
{
	Response response {};

	switch (_pimpl->state)
	{
		case impl::VisitorState::Complete:
			_pimpl->state = impl::VisitorState::Start;
			std::swap(_pimpl->response, response);
			break;

		default:
			break;
	}

	return response;
}

Response parseResponse(response::Value&& response)
{
	using namespace graphql::client;

	Response result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(appointments)js"sv)
			{
				result.appointments = ModifiedResponse<query::Appointments::Response::appointments_AppointmentConnection>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetRequestText() noexcept
{
	return client::GetRequestText();
}

[[nodiscard("unnecessary call")]] const peg::ast& Traits::GetRequestObject() noexcept
{
	return client::GetRequestObject();
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetOperationName() noexcept
{
	return Appointments::GetOperationName();
}

[[nodiscard("unnecessary conversion")]] Traits::Response Traits::parseResponse(response::Value&& response)
{
	return Appointments::parseResponse(std::move(response));
}

} // namespace multiple::client::query::Appointments
namespace client {

using namespace multiple;

template <>
graphql::multiple::client::query::Tasks::Response::tasks_TaskConnection::edges_TaskEdge::node_Task Response<graphql::multiple::client::query::Tasks::Response::tasks_TaskConnection::edges_TaskEdge::node_Task>::parse(response::Value&& response)
{
	graphql::multiple::client::query::Tasks::Response::tasks_TaskConnection::edges_TaskEdge::node_Task result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(id)js"sv)
			{
				result.id = ModifiedResponse<response::IdType>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(title)js"sv)
			{
				result.title = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
			if (member.first == R"js(isComplete)js"sv)
			{
				result.isComplete = ModifiedResponse<bool>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(__typename)js"sv)
			{
				result._typename = ModifiedResponse<std::string>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
graphql::multiple::client::query::Tasks::Response::tasks_TaskConnection::edges_TaskEdge Response<graphql::multiple::client::query::Tasks::Response::tasks_TaskConnection::edges_TaskEdge>::parse(response::Value&& response)
{
	graphql::multiple::client::query::Tasks::Response::tasks_TaskConnection::edges_TaskEdge result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(node)js"sv)
			{
				result.node = ModifiedResponse<graphql::multiple::client::query::Tasks::Response::tasks_TaskConnection::edges_TaskEdge::node_Task>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
graphql::multiple::client::query::Tasks::Response::tasks_TaskConnection Response<graphql::multiple::client::query::Tasks::Response::tasks_TaskConnection>::parse(response::Value&& response)
{
	graphql::multiple::client::query::Tasks::Response::tasks_TaskConnection result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(edges)js"sv)
			{
				result.edges = ModifiedResponse<graphql::multiple::client::query::Tasks::Response::tasks_TaskConnection::edges_TaskEdge>::parse<TypeModifier::Nullable, TypeModifier::List, TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

} // namespace client

namespace multiple::client::query::Tasks {

const std::string& GetOperationName() noexcept
{
	static const auto s_name = R"gql(Tasks)gql"s;

	return s_name;
}

struct ResponseVisitor::impl
{
	enum class VisitorState
	{
		Start,
		Member_tasks,
		Member_tasks_edges,
		Member_tasks_edges_0,
		Member_tasks_edges_0_,
		Member_tasks_edges_0_node,
		Member_tasks_edges_0_node_id,
		Member_tasks_edges_0_node_title,
		Member_tasks_edges_0_node_isComplete,
		Member_tasks_edges_0_node__typename,
		Complete,
	};

	VisitorState state { VisitorState::Start };
	Response response {};
};

ResponseVisitor::ResponseVisitor() noexcept
	: _pimpl { std::make_unique<impl>() }
{
}

ResponseVisitor::~ResponseVisitor()
{
}

void ResponseVisitor::add_value([[maybe_unused]] std::shared_ptr<const response::Value>&& value)
{
	using namespace graphql::client;

	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_tasks:
			_pimpl->state = impl::VisitorState::Start;
			_pimpl->response.tasks = ModifiedResponse<Response::tasks_TaskConnection>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_tasks_edges_0:
			_pimpl->response.tasks.edges->push_back(ModifiedResponse<Response::tasks_TaskConnection::edges_TaskEdge>::parse<TypeModifier::Nullable>(response::Value { *value }));
			break;

		case impl::VisitorState::Member_tasks_edges_0_node:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0_;
			_pimpl->response.tasks.edges->back()->node = ModifiedResponse<Response::tasks_TaskConnection::edges_TaskEdge::node_Task>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		case impl::VisitorState::Member_tasks_edges_0_node_id:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node;
			_pimpl->response.tasks.edges->back()->node->id = ModifiedResponse<response::IdType>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_tasks_edges_0_node_title:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node;
			_pimpl->response.tasks.edges->back()->node->title = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		case impl::VisitorState::Member_tasks_edges_0_node_isComplete:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node;
			_pimpl->response.tasks.edges->back()->node->isComplete = ModifiedResponse<bool>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_tasks_edges_0_node__typename:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node;
			_pimpl->response.tasks.edges->back()->node->_typename = ModifiedResponse<std::string>::parse(response::Value { *value });
			break;

		default:
			break;
	}
}

void ResponseVisitor::reserve([[maybe_unused]] std::size_t count)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_tasks_edges_0:
			_pimpl->response.tasks.edges->reserve(count);
			break;

		default:
			break;
	}
}

void ResponseVisitor::start_object()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_tasks_edges_0:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0_;
			_pimpl->response.tasks.edges->push_back(std::make_optional<Response::tasks_TaskConnection::edges_TaskEdge>({}));
			break;

		case impl::VisitorState::Member_tasks_edges_0_node:
			_pimpl->response.tasks.edges->back()->node = std::make_optional<Response::tasks_TaskConnection::edges_TaskEdge::node_Task>({});
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_member([[maybe_unused]] std::string&& key)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Start:
			if (key == "tasks"sv)
			{
				_pimpl->state = impl::VisitorState::Member_tasks;
			}
			break;

		case impl::VisitorState::Member_tasks:
			if (key == "edges"sv)
			{
				_pimpl->state = impl::VisitorState::Member_tasks_edges;
			}
			break;

		case impl::VisitorState::Member_tasks_edges_0_:
			if (key == "node"sv)
			{
				_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node;
			}
			break;

		case impl::VisitorState::Member_tasks_edges_0_node:
			if (key == "id"sv)
			{
				_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node_id;
			}
			else if (key == "title"sv)
			{
				_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node_title;
			}
			else if (key == "isComplete"sv)
			{
				_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node_isComplete;
			}
			else if (key == "__typename"sv)
			{
				_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node__typename;
			}
			break;

		default:
			break;
	}
}

void ResponseVisitor::end_object()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_tasks_edges_0_node:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0_;
			break;

		case impl::VisitorState::Member_tasks_edges_0_:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0;
			break;

		case impl::VisitorState::Member_tasks:
			_pimpl->state = impl::VisitorState::Start;
			break;

		default:
			break;
	}
}

void ResponseVisitor::start_array()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_tasks_edges:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0;
			_pimpl->response.tasks.edges = std::make_optional<std::vector<std::optional<Response::tasks_TaskConnection::edges_TaskEdge>>>({});
			break;

		default:
			break;
	}
}

void ResponseVisitor::end_array()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_tasks_edges_0:
			_pimpl->state = impl::VisitorState::Member_tasks;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_null()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_tasks_edges_0:
			_pimpl->response.tasks.edges->push_back(std::nullopt);
			break;

		case impl::VisitorState::Member_tasks_edges_0_node:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0_;
			_pimpl->response.tasks.edges->back()->node = std::nullopt;
			break;

		case impl::VisitorState::Member_tasks_edges_0_node_title:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node;
			_pimpl->response.tasks.edges->back()->node->title = std::nullopt;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_string([[maybe_unused]] std::string&& value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_tasks_edges_0_node_title:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node;
			_pimpl->response.tasks.edges->back()->node->title = std::move(value);
			break;

		case impl::VisitorState::Member_tasks_edges_0_node__typename:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node;
			_pimpl->response.tasks.edges->back()->node->_typename = std::move(value);
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_enum([[maybe_unused]] std::string&& value)
{
	using namespace graphql::client;

	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_id([[maybe_unused]] response::IdType&& value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_tasks_edges_0_node_id:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node;
			_pimpl->response.tasks.edges->back()->node->id = std::move(value);
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_bool([[maybe_unused]] bool value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_tasks_edges_0_node_isComplete:
			_pimpl->state = impl::VisitorState::Member_tasks_edges_0_node;
			_pimpl->response.tasks.edges->back()->node->isComplete = value;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_int([[maybe_unused]] int value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_float([[maybe_unused]] double value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::complete()
{
	_pimpl->state = impl::VisitorState::Complete;
}

Response ResponseVisitor::response()
{
	Response response {};

	switch (_pimpl->state)
	{
		case impl::VisitorState::Complete:
			_pimpl->state = impl::VisitorState::Start;
			std::swap(_pimpl->response, response);
			break;

		default:
			break;
	}

	return response;
}

Response parseResponse(response::Value&& response)
{
	using namespace graphql::client;

	Response result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(tasks)js"sv)
			{
				result.tasks = ModifiedResponse<query::Tasks::Response::tasks_TaskConnection>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetRequestText() noexcept
{
	return client::GetRequestText();
}

[[nodiscard("unnecessary call")]] const peg::ast& Traits::GetRequestObject() noexcept
{
	return client::GetRequestObject();
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetOperationName() noexcept
{
	return Tasks::GetOperationName();
}

[[nodiscard("unnecessary conversion")]] Traits::Response Traits::parseResponse(response::Value&& response)
{
	return Tasks::parseResponse(std::move(response));
}

} // namespace multiple::client::query::Tasks
namespace client {

using namespace multiple;

template <>
graphql::multiple::client::query::UnreadCounts::Response::unreadCounts_FolderConnection::edges_FolderEdge::node_Folder Response<graphql::multiple::client::query::UnreadCounts::Response::unreadCounts_FolderConnection::edges_FolderEdge::node_Folder>::parse(response::Value&& response)
{
	graphql::multiple::client::query::UnreadCounts::Response::unreadCounts_FolderConnection::edges_FolderEdge::node_Folder result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(id)js"sv)
			{
				result.id = ModifiedResponse<response::IdType>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(name)js"sv)
			{
				result.name = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
			if (member.first == R"js(unreadCount)js"sv)
			{
				result.unreadCount = ModifiedResponse<int>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(__typename)js"sv)
			{
				result._typename = ModifiedResponse<std::string>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
graphql::multiple::client::query::UnreadCounts::Response::unreadCounts_FolderConnection::edges_FolderEdge Response<graphql::multiple::client::query::UnreadCounts::Response::unreadCounts_FolderConnection::edges_FolderEdge>::parse(response::Value&& response)
{
	graphql::multiple::client::query::UnreadCounts::Response::unreadCounts_FolderConnection::edges_FolderEdge result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(node)js"sv)
			{
				result.node = ModifiedResponse<graphql::multiple::client::query::UnreadCounts::Response::unreadCounts_FolderConnection::edges_FolderEdge::node_Folder>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
graphql::multiple::client::query::UnreadCounts::Response::unreadCounts_FolderConnection Response<graphql::multiple::client::query::UnreadCounts::Response::unreadCounts_FolderConnection>::parse(response::Value&& response)
{
	graphql::multiple::client::query::UnreadCounts::Response::unreadCounts_FolderConnection result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(edges)js"sv)
			{
				result.edges = ModifiedResponse<graphql::multiple::client::query::UnreadCounts::Response::unreadCounts_FolderConnection::edges_FolderEdge>::parse<TypeModifier::Nullable, TypeModifier::List, TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

} // namespace client

namespace multiple::client::query::UnreadCounts {

const std::string& GetOperationName() noexcept
{
	static const auto s_name = R"gql(UnreadCounts)gql"s;

	return s_name;
}

struct ResponseVisitor::impl
{
	enum class VisitorState
	{
		Start,
		Member_unreadCounts,
		Member_unreadCounts_edges,
		Member_unreadCounts_edges_0,
		Member_unreadCounts_edges_0_,
		Member_unreadCounts_edges_0_node,
		Member_unreadCounts_edges_0_node_id,
		Member_unreadCounts_edges_0_node_name,
		Member_unreadCounts_edges_0_node_unreadCount,
		Member_unreadCounts_edges_0_node__typename,
		Complete,
	};

	VisitorState state { VisitorState::Start };
	Response response {};
};

ResponseVisitor::ResponseVisitor() noexcept
	: _pimpl { std::make_unique<impl>() }
{
}

ResponseVisitor::~ResponseVisitor()
{
}

void ResponseVisitor::add_value([[maybe_unused]] std::shared_ptr<const response::Value>&& value)
{
	using namespace graphql::client;

	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_unreadCounts:
			_pimpl->state = impl::VisitorState::Start;
			_pimpl->response.unreadCounts = ModifiedResponse<Response::unreadCounts_FolderConnection>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_unreadCounts_edges_0:
			_pimpl->response.unreadCounts.edges->push_back(ModifiedResponse<Response::unreadCounts_FolderConnection::edges_FolderEdge>::parse<TypeModifier::Nullable>(response::Value { *value }));
			break;

		case impl::VisitorState::Member_unreadCounts_edges_0_node:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_;
			_pimpl->response.unreadCounts.edges->back()->node = ModifiedResponse<Response::unreadCounts_FolderConnection::edges_FolderEdge::node_Folder>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		case impl::VisitorState::Member_unreadCounts_edges_0_node_id:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node;
			_pimpl->response.unreadCounts.edges->back()->node->id = ModifiedResponse<response::IdType>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_unreadCounts_edges_0_node_name:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node;
			_pimpl->response.unreadCounts.edges->back()->node->name = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		case impl::VisitorState::Member_unreadCounts_edges_0_node_unreadCount:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node;
			_pimpl->response.unreadCounts.edges->back()->node->unreadCount = ModifiedResponse<int>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_unreadCounts_edges_0_node__typename:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node;
			_pimpl->response.unreadCounts.edges->back()->node->_typename = ModifiedResponse<std::string>::parse(response::Value { *value });
			break;

		default:
			break;
	}
}

void ResponseVisitor::reserve([[maybe_unused]] std::size_t count)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_unreadCounts_edges_0:
			_pimpl->response.unreadCounts.edges->reserve(count);
			break;

		default:
			break;
	}
}

void ResponseVisitor::start_object()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_unreadCounts_edges_0:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_;
			_pimpl->response.unreadCounts.edges->push_back(std::make_optional<Response::unreadCounts_FolderConnection::edges_FolderEdge>({}));
			break;

		case impl::VisitorState::Member_unreadCounts_edges_0_node:
			_pimpl->response.unreadCounts.edges->back()->node = std::make_optional<Response::unreadCounts_FolderConnection::edges_FolderEdge::node_Folder>({});
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_member([[maybe_unused]] std::string&& key)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Start:
			if (key == "unreadCounts"sv)
			{
				_pimpl->state = impl::VisitorState::Member_unreadCounts;
			}
			break;

		case impl::VisitorState::Member_unreadCounts:
			if (key == "edges"sv)
			{
				_pimpl->state = impl::VisitorState::Member_unreadCounts_edges;
			}
			break;

		case impl::VisitorState::Member_unreadCounts_edges_0_:
			if (key == "node"sv)
			{
				_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node;
			}
			break;

		case impl::VisitorState::Member_unreadCounts_edges_0_node:
			if (key == "id"sv)
			{
				_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node_id;
			}
			else if (key == "name"sv)
			{
				_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node_name;
			}
			else if (key == "unreadCount"sv)
			{
				_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node_unreadCount;
			}
			else if (key == "__typename"sv)
			{
				_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node__typename;
			}
			break;

		default:
			break;
	}
}

void ResponseVisitor::end_object()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_unreadCounts_edges_0_node:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_;
			break;

		case impl::VisitorState::Member_unreadCounts_edges_0_:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0;
			break;

		case impl::VisitorState::Member_unreadCounts:
			_pimpl->state = impl::VisitorState::Start;
			break;

		default:
			break;
	}
}

void ResponseVisitor::start_array()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_unreadCounts_edges:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0;
			_pimpl->response.unreadCounts.edges = std::make_optional<std::vector<std::optional<Response::unreadCounts_FolderConnection::edges_FolderEdge>>>({});
			break;

		default:
			break;
	}
}

void ResponseVisitor::end_array()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_unreadCounts_edges_0:
			_pimpl->state = impl::VisitorState::Member_unreadCounts;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_null()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_unreadCounts_edges_0:
			_pimpl->response.unreadCounts.edges->push_back(std::nullopt);
			break;

		case impl::VisitorState::Member_unreadCounts_edges_0_node:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_;
			_pimpl->response.unreadCounts.edges->back()->node = std::nullopt;
			break;

		case impl::VisitorState::Member_unreadCounts_edges_0_node_name:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node;
			_pimpl->response.unreadCounts.edges->back()->node->name = std::nullopt;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_string([[maybe_unused]] std::string&& value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_unreadCounts_edges_0_node_name:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node;
			_pimpl->response.unreadCounts.edges->back()->node->name = std::move(value);
			break;

		case impl::VisitorState::Member_unreadCounts_edges_0_node__typename:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node;
			_pimpl->response.unreadCounts.edges->back()->node->_typename = std::move(value);
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_enum([[maybe_unused]] std::string&& value)
{
	using namespace graphql::client;

	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_id([[maybe_unused]] response::IdType&& value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_unreadCounts_edges_0_node_id:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node;
			_pimpl->response.unreadCounts.edges->back()->node->id = std::move(value);
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_bool([[maybe_unused]] bool value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_int([[maybe_unused]] int value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_unreadCounts_edges_0_node_unreadCount:
			_pimpl->state = impl::VisitorState::Member_unreadCounts_edges_0_node;
			_pimpl->response.unreadCounts.edges->back()->node->unreadCount = value;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_float([[maybe_unused]] double value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::complete()
{
	_pimpl->state = impl::VisitorState::Complete;
}

Response ResponseVisitor::response()
{
	Response response {};

	switch (_pimpl->state)
	{
		case impl::VisitorState::Complete:
			_pimpl->state = impl::VisitorState::Start;
			std::swap(_pimpl->response, response);
			break;

		default:
			break;
	}

	return response;
}

Response parseResponse(response::Value&& response)
{
	using namespace graphql::client;

	Response result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(unreadCounts)js"sv)
			{
				result.unreadCounts = ModifiedResponse<query::UnreadCounts::Response::unreadCounts_FolderConnection>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetRequestText() noexcept
{
	return client::GetRequestText();
}

[[nodiscard("unnecessary call")]] const peg::ast& Traits::GetRequestObject() noexcept
{
	return client::GetRequestObject();
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetOperationName() noexcept
{
	return UnreadCounts::GetOperationName();
}

[[nodiscard("unnecessary conversion")]] Traits::Response Traits::parseResponse(response::Value&& response)
{
	return UnreadCounts::parseResponse(std::move(response));
}

} // namespace multiple::client::query::UnreadCounts

namespace client {

using namespace multiple;

static const std::array<std::pair<std::string_view, TaskState>, 4> s_valuesTaskState = {
	std::make_pair(R"gql(New)gql"sv, TaskState::New),
	std::make_pair(R"gql(Started)gql"sv, TaskState::Started),
	std::make_pair(R"gql(Complete)gql"sv, TaskState::Complete),
	std::make_pair(R"gql(Unassigned)gql"sv, TaskState::Unassigned)
};
			
template <>
TaskState Response<TaskState>::parse(response::Value&& value)
{
	if (!value.maybe_enum())
	{
		throw std::logic_error { R"ex(not a valid TaskState value)ex" };
	}

	const auto result = internal::sorted_map_lookup<internal::shorter_or_less>(
		s_valuesTaskState,
		std::string_view { value.get<std::string>() });

	if (!result)
	{
		throw std::logic_error { R"ex(not a valid TaskState value)ex" };
	}

	return *result;
}

template <>
graphql::multiple::client::query::Miscellaneous::Response::anyType_UnionType Response<graphql::multiple::client::query::Miscellaneous::Response::anyType_UnionType>::parse(response::Value&& response)
{
	graphql::multiple::client::query::Miscellaneous::Response::anyType_UnionType result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(__typename)js"sv)
			{
				result._typename = ModifiedResponse<std::string>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(id)js"sv)
			{
				result.id = ModifiedResponse<response::IdType>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(title)js"sv)
			{
				result.title = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
			if (member.first == R"js(isComplete)js"sv)
			{
				result.isComplete = ModifiedResponse<bool>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(subject)js"sv)
			{
				result.subject = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
			if (member.first == R"js(when)js"sv)
			{
				result.when = ModifiedResponse<response::Value>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
			if (member.first == R"js(isNow)js"sv)
			{
				result.isNow = ModifiedResponse<bool>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

} // namespace client

namespace multiple::client::query::Miscellaneous {

const std::string& GetOperationName() noexcept
{
	static const auto s_name = R"gql(Miscellaneous)gql"s;

	return s_name;
}

struct ResponseVisitor::impl
{
	enum class VisitorState
	{
		Start,
		Member_testTaskState,
		Member_anyType,
		Member_anyType_0,
		Member_anyType_0_,
		Member_anyType_0__typename,
		Member_anyType_0_id,
		Member_anyType_0_title,
		Member_anyType_0_isComplete,
		Member_anyType_0_subject,
		Member_anyType_0_when,
		Member_anyType_0_isNow,
		Member_default_,
		Complete,
	};

	VisitorState state { VisitorState::Start };
	Response response {};
};

ResponseVisitor::ResponseVisitor() noexcept
	: _pimpl { std::make_unique<impl>() }
{
}

ResponseVisitor::~ResponseVisitor()
{
}

void ResponseVisitor::add_value([[maybe_unused]] std::shared_ptr<const response::Value>&& value)
{
	using namespace graphql::client;

	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_testTaskState:
			_pimpl->state = impl::VisitorState::Start;
			_pimpl->response.testTaskState = ModifiedResponse<TaskState>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_anyType_0:
			_pimpl->response.anyType.push_back(ModifiedResponse<Response::anyType_UnionType>::parse<TypeModifier::Nullable>(response::Value { *value }));
			break;

		case impl::VisitorState::Member_anyType_0__typename:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->_typename = ModifiedResponse<std::string>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_anyType_0_id:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->id = ModifiedResponse<response::IdType>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_anyType_0_title:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->title = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		case impl::VisitorState::Member_anyType_0_isComplete:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->isComplete = ModifiedResponse<bool>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_anyType_0_subject:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->subject = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		case impl::VisitorState::Member_anyType_0_when:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->when = ModifiedResponse<response::Value>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		case impl::VisitorState::Member_anyType_0_isNow:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->isNow = ModifiedResponse<bool>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_default_:
			_pimpl->state = impl::VisitorState::Start;
			_pimpl->response.default_ = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		default:
			break;
	}
}

void ResponseVisitor::reserve([[maybe_unused]] std::size_t count)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_anyType_0:
			_pimpl->response.anyType.reserve(count);
			break;

		default:
			break;
	}
}

void ResponseVisitor::start_object()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_anyType_0:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.push_back(std::make_optional<Response::anyType_UnionType>({}));
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_member([[maybe_unused]] std::string&& key)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Start:
			if (key == "testTaskState"sv)
			{
				_pimpl->state = impl::VisitorState::Member_testTaskState;
			}
			else if (key == "anyType"sv)
			{
				_pimpl->state = impl::VisitorState::Member_anyType;
			}
			else if (key == "default"sv)
			{
				_pimpl->state = impl::VisitorState::Member_default_;
			}
			break;

		case impl::VisitorState::Member_anyType_0_:
			if (key == "__typename"sv)
			{
				_pimpl->state = impl::VisitorState::Member_anyType_0__typename;
			}
			else if (key == "id"sv)
			{
				_pimpl->state = impl::VisitorState::Member_anyType_0_id;
			}
			else if (key == "title"sv)
			{
				_pimpl->state = impl::VisitorState::Member_anyType_0_title;
			}
			else if (key == "isComplete"sv)
			{
				_pimpl->state = impl::VisitorState::Member_anyType_0_isComplete;
			}
			else if (key == "subject"sv)
			{
				_pimpl->state = impl::VisitorState::Member_anyType_0_subject;
			}
			else if (key == "when"sv)
			{
				_pimpl->state = impl::VisitorState::Member_anyType_0_when;
			}
			else if (key == "isNow"sv)
			{
				_pimpl->state = impl::VisitorState::Member_anyType_0_isNow;
			}
			break;

		default:
			break;
	}
}

void ResponseVisitor::end_object()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_anyType_0_:
			_pimpl->state = impl::VisitorState::Member_anyType_0;
			break;

		default:
			break;
	}
}

void ResponseVisitor::start_array()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_anyType:
			_pimpl->state = impl::VisitorState::Member_anyType_0;
			break;

		default:
			break;
	}
}

void ResponseVisitor::end_array()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_anyType_0:
			_pimpl->state = impl::VisitorState::Start;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_null()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_anyType_0:
			_pimpl->response.anyType.push_back(std::nullopt);
			break;

		case impl::VisitorState::Member_anyType_0_title:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->title = std::nullopt;
			break;

		case impl::VisitorState::Member_anyType_0_subject:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->subject = std::nullopt;
			break;

		case impl::VisitorState::Member_anyType_0_when:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->when = std::nullopt;
			break;

		case impl::VisitorState::Member_default_:
			_pimpl->state = impl::VisitorState::Start;
			_pimpl->response.default_ = std::nullopt;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_string([[maybe_unused]] std::string&& value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_anyType_0__typename:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->_typename = std::move(value);
			break;

		case impl::VisitorState::Member_anyType_0_title:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->title = std::move(value);
			break;

		case impl::VisitorState::Member_anyType_0_subject:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->subject = std::move(value);
			break;

		case impl::VisitorState::Member_default_:
			_pimpl->state = impl::VisitorState::Start;
			_pimpl->response.default_ = std::move(value);
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_enum([[maybe_unused]] std::string&& value)
{
	using namespace graphql::client;

	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_testTaskState:
			_pimpl->state = impl::VisitorState::Start;
			if (const auto enumValue = internal::sorted_map_lookup<internal::shorter_or_less>(s_valuesTaskState, std::string_view { value }))
			{
				_pimpl->response.testTaskState = *enumValue;
			}
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_id([[maybe_unused]] response::IdType&& value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_anyType_0_id:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->id = std::move(value);
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_bool([[maybe_unused]] bool value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_anyType_0_isComplete:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->isComplete = value;
			break;

		case impl::VisitorState::Member_anyType_0_isNow:
			_pimpl->state = impl::VisitorState::Member_anyType_0_;
			_pimpl->response.anyType.back()->isNow = value;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_int([[maybe_unused]] int value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_float([[maybe_unused]] double value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::complete()
{
	_pimpl->state = impl::VisitorState::Complete;
}

Response ResponseVisitor::response()
{
	Response response {};

	switch (_pimpl->state)
	{
		case impl::VisitorState::Complete:
			_pimpl->state = impl::VisitorState::Start;
			std::swap(_pimpl->response, response);
			break;

		default:
			break;
	}

	return response;
}

Response parseResponse(response::Value&& response)
{
	using namespace graphql::client;

	Response result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(testTaskState)js"sv)
			{
				result.testTaskState = ModifiedResponse<TaskState>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(anyType)js"sv)
			{
				result.anyType = ModifiedResponse<query::Miscellaneous::Response::anyType_UnionType>::parse<TypeModifier::List, TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
			if (member.first == R"js(default)js"sv)
			{
				result.default_ = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetRequestText() noexcept
{
	return client::GetRequestText();
}

[[nodiscard("unnecessary call")]] const peg::ast& Traits::GetRequestObject() noexcept
{
	return client::GetRequestObject();
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetOperationName() noexcept
{
	return Miscellaneous::GetOperationName();
}

[[nodiscard("unnecessary conversion")]] Traits::Response Traits::parseResponse(response::Value&& response)
{
	return Miscellaneous::parseResponse(std::move(response));
}

} // namespace multiple::client::query::Miscellaneous

namespace client {

using namespace multiple;

template <>
response::Value Variable<TaskState>::serialize(TaskState&& value)
{
	static const std::array<std::string_view, 4> s_names = {
		R"gql(Unassigned)gql"sv,
		R"gql(New)gql"sv,
		R"gql(Started)gql"sv,
		R"gql(Complete)gql"sv
	};

	response::Value result { response::Type::EnumValue };

	result.set<std::string>(std::string { s_names[static_cast<std::size_t>(value)] });

	return result;
}

template <>
response::Value Variable<CompleteTaskInput>::serialize(CompleteTaskInput&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(id)js"s, ModifiedVariable<response::IdType>::serialize(std::move(inputValue.id)));
	result.emplace_back(R"js(testTaskState)js"s, ModifiedVariable<TaskState>::serialize<TypeModifier::Nullable>(std::move(inputValue.testTaskState)));
	result.emplace_back(R"js(isComplete)js"s, ModifiedVariable<bool>::serialize<TypeModifier::Nullable>(std::move(inputValue.isComplete)));
	result.emplace_back(R"js(clientMutationId)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.clientMutationId)));

	return result;
}

template <>
graphql::multiple::client::mutation::CompleteTaskMutation::Response::completedTask_CompleteTaskPayload::completedTask_Task Response<graphql::multiple::client::mutation::CompleteTaskMutation::Response::completedTask_CompleteTaskPayload::completedTask_Task>::parse(response::Value&& response)
{
	graphql::multiple::client::mutation::CompleteTaskMutation::Response::completedTask_CompleteTaskPayload::completedTask_Task result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(completedTaskId)js"sv)
			{
				result.completedTaskId = ModifiedResponse<response::IdType>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(title)js"sv)
			{
				result.title = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
			if (member.first == R"js(isComplete)js"sv)
			{
				result.isComplete = ModifiedResponse<bool>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
graphql::multiple::client::mutation::CompleteTaskMutation::Response::completedTask_CompleteTaskPayload Response<graphql::multiple::client::mutation::CompleteTaskMutation::Response::completedTask_CompleteTaskPayload>::parse(response::Value&& response)
{
	graphql::multiple::client::mutation::CompleteTaskMutation::Response::completedTask_CompleteTaskPayload result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(completedTask)js"sv)
			{
				result.completedTask = ModifiedResponse<graphql::multiple::client::mutation::CompleteTaskMutation::Response::completedTask_CompleteTaskPayload::completedTask_Task>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
			if (member.first == R"js(clientMutationId)js"sv)
			{
				result.clientMutationId = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

} // namespace client

namespace multiple::client::mutation::CompleteTaskMutation {

const std::string& GetOperationName() noexcept
{
	static const auto s_name = R"gql(CompleteTaskMutation)gql"s;

	return s_name;
}

response::Value serializeVariables(Variables&& variables)
{
	using namespace graphql::client;

	response::Value result { response::Type::Map };

	result.emplace_back(R"js(input)js"s, ModifiedVariable<CompleteTaskInput>::serialize<TypeModifier::Nullable>(std::move(variables.input)));
	result.emplace_back(R"js(skipClientMutationId)js"s, ModifiedVariable<bool>::serialize(std::move(variables.skipClientMutationId)));

	return result;
}

struct ResponseVisitor::impl
{
	enum class VisitorState
	{
		Start,
		Member_completedTask,
		Member_completedTask_completedTask,
		Member_completedTask_completedTask_completedTaskId,
		Member_completedTask_completedTask_title,
		Member_completedTask_completedTask_isComplete,
		Member_completedTask_clientMutationId,
		Complete,
	};

	VisitorState state { VisitorState::Start };
	Response response {};
};

ResponseVisitor::ResponseVisitor() noexcept
	: _pimpl { std::make_unique<impl>() }
{
}

ResponseVisitor::~ResponseVisitor()
{
}

void ResponseVisitor::add_value([[maybe_unused]] std::shared_ptr<const response::Value>&& value)
{
	using namespace graphql::client;

	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_completedTask:
			_pimpl->state = impl::VisitorState::Start;
			_pimpl->response.completedTask = ModifiedResponse<Response::completedTask_CompleteTaskPayload>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_completedTask_completedTask:
			_pimpl->state = impl::VisitorState::Member_completedTask;
			_pimpl->response.completedTask.completedTask = ModifiedResponse<Response::completedTask_CompleteTaskPayload::completedTask_Task>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		case impl::VisitorState::Member_completedTask_completedTask_completedTaskId:
			_pimpl->state = impl::VisitorState::Member_completedTask_completedTask;
			_pimpl->response.completedTask.completedTask->completedTaskId = ModifiedResponse<response::IdType>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_completedTask_completedTask_title:
			_pimpl->state = impl::VisitorState::Member_completedTask_completedTask;
			_pimpl->response.completedTask.completedTask->title = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		case impl::VisitorState::Member_completedTask_completedTask_isComplete:
			_pimpl->state = impl::VisitorState::Member_completedTask_completedTask;
			_pimpl->response.completedTask.completedTask->isComplete = ModifiedResponse<bool>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_completedTask_clientMutationId:
			_pimpl->state = impl::VisitorState::Member_completedTask;
			_pimpl->response.completedTask.clientMutationId = ModifiedResponse<std::string>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		default:
			break;
	}
}

void ResponseVisitor::reserve([[maybe_unused]] std::size_t count)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::start_object()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_completedTask_completedTask:
			_pimpl->response.completedTask.completedTask = std::make_optional<Response::completedTask_CompleteTaskPayload::completedTask_Task>({});
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_member([[maybe_unused]] std::string&& key)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Start:
			if (key == "completedTask"sv)
			{
				_pimpl->state = impl::VisitorState::Member_completedTask;
			}
			break;

		case impl::VisitorState::Member_completedTask:
			if (key == "completedTask"sv)
			{
				_pimpl->state = impl::VisitorState::Member_completedTask_completedTask;
			}
			else if (key == "clientMutationId"sv)
			{
				_pimpl->state = impl::VisitorState::Member_completedTask_clientMutationId;
			}
			break;

		case impl::VisitorState::Member_completedTask_completedTask:
			if (key == "completedTaskId"sv)
			{
				_pimpl->state = impl::VisitorState::Member_completedTask_completedTask_completedTaskId;
			}
			else if (key == "title"sv)
			{
				_pimpl->state = impl::VisitorState::Member_completedTask_completedTask_title;
			}
			else if (key == "isComplete"sv)
			{
				_pimpl->state = impl::VisitorState::Member_completedTask_completedTask_isComplete;
			}
			break;

		default:
			break;
	}
}

void ResponseVisitor::end_object()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_completedTask_completedTask:
			_pimpl->state = impl::VisitorState::Member_completedTask;
			break;

		case impl::VisitorState::Member_completedTask:
			_pimpl->state = impl::VisitorState::Start;
			break;

		default:
			break;
	}
}

void ResponseVisitor::start_array()
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::end_array()
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_null()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_completedTask_completedTask:
			_pimpl->state = impl::VisitorState::Member_completedTask;
			_pimpl->response.completedTask.completedTask = std::nullopt;
			break;

		case impl::VisitorState::Member_completedTask_completedTask_title:
			_pimpl->state = impl::VisitorState::Member_completedTask_completedTask;
			_pimpl->response.completedTask.completedTask->title = std::nullopt;
			break;

		case impl::VisitorState::Member_completedTask_clientMutationId:
			_pimpl->state = impl::VisitorState::Member_completedTask;
			_pimpl->response.completedTask.clientMutationId = std::nullopt;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_string([[maybe_unused]] std::string&& value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_completedTask_completedTask_title:
			_pimpl->state = impl::VisitorState::Member_completedTask_completedTask;
			_pimpl->response.completedTask.completedTask->title = std::move(value);
			break;

		case impl::VisitorState::Member_completedTask_clientMutationId:
			_pimpl->state = impl::VisitorState::Member_completedTask;
			_pimpl->response.completedTask.clientMutationId = std::move(value);
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_enum([[maybe_unused]] std::string&& value)
{
	using namespace graphql::client;

	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_id([[maybe_unused]] response::IdType&& value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_completedTask_completedTask_completedTaskId:
			_pimpl->state = impl::VisitorState::Member_completedTask_completedTask;
			_pimpl->response.completedTask.completedTask->completedTaskId = std::move(value);
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_bool([[maybe_unused]] bool value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_completedTask_completedTask_isComplete:
			_pimpl->state = impl::VisitorState::Member_completedTask_completedTask;
			_pimpl->response.completedTask.completedTask->isComplete = value;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_int([[maybe_unused]] int value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_float([[maybe_unused]] double value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::complete()
{
	_pimpl->state = impl::VisitorState::Complete;
}

Response ResponseVisitor::response()
{
	Response response {};

	switch (_pimpl->state)
	{
		case impl::VisitorState::Complete:
			_pimpl->state = impl::VisitorState::Start;
			std::swap(_pimpl->response, response);
			break;

		default:
			break;
	}

	return response;
}

Response parseResponse(response::Value&& response)
{
	using namespace graphql::client;

	Response result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(completedTask)js"sv)
			{
				result.completedTask = ModifiedResponse<mutation::CompleteTaskMutation::Response::completedTask_CompleteTaskPayload>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetRequestText() noexcept
{
	return client::GetRequestText();
}

[[nodiscard("unnecessary call")]] const peg::ast& Traits::GetRequestObject() noexcept
{
	return client::GetRequestObject();
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetOperationName() noexcept
{
	return CompleteTaskMutation::GetOperationName();
}

[[nodiscard("unnecessary conversion")]] response::Value Traits::serializeVariables(Traits::Variables&& variables)
{
	return CompleteTaskMutation::serializeVariables(std::move(variables));
}

[[nodiscard("unnecessary conversion")]] Traits::Response Traits::parseResponse(response::Value&& response)
{
	return CompleteTaskMutation::parseResponse(std::move(response));
}

} // namespace multiple::client::mutation::CompleteTaskMutation
} // namespace graphql
