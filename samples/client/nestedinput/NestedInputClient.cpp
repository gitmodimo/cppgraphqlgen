// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// WARNING! Do not edit this file manually, your changes will be overwritten.

#include "NestedInputClient.h"

#include "graphqlservice/internal/SortedMap.h"

#include <algorithm>
#include <array>
#include <cstddef>
#include <stdexcept>
#include <string_view>
#include <utility>

using namespace std::literals;

namespace graphql {
namespace nestedinput {
namespace client {

const std::string& GetRequestText() noexcept
{
	static const auto s_request = R"gql(
		query testQuery($stream: InputABCD!) {
		  control {
		    test(new: $stream) {
		      id
		    }
		  }
		}
	)gql"s;

	return s_request;
}

const peg::ast& GetRequestObject() noexcept
{
	static const auto s_request = []() noexcept {
		auto ast = peg::parseString(GetRequestText());

		// This has already been validated against the schema by clientgen.
		ast.validated = true;

		return ast;
	}();

	return s_request;
}

} // namespace client

using namespace graphql::client;

InputA::InputA() noexcept
	: a {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

InputA::InputA(
		bool aArg) noexcept
	: a { std::move(aArg) }
{
}

InputA::InputA(const InputA& other)
	: a { ModifiedVariable<bool>::duplicate(other.a) }
{
}

InputA::InputA(InputA&& other) noexcept
	: a { std::move(other.a) }
{
}

InputA::~InputA()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

InputA& InputA::operator=(const InputA& other)
{
	return *this = InputA { other };
}

InputA& InputA::operator=(InputA&& other) noexcept
{
	a = std::move(other.a);

	return *this;
}

InputB::InputB() noexcept
	: b {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

InputB::InputB(
		double bArg) noexcept
	: b { std::move(bArg) }
{
}

InputB::InputB(const InputB& other)
	: b { ModifiedVariable<double>::duplicate(other.b) }
{
}

InputB::InputB(InputB&& other) noexcept
	: b { std::move(other.b) }
{
}

InputB::~InputB()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

InputB& InputB::operator=(const InputB& other)
{
	return *this = InputB { other };
}

InputB& InputB::operator=(InputB&& other) noexcept
{
	b = std::move(other.b);

	return *this;
}

InputABCD::InputABCD() noexcept
	: d {}
	, a {}
	, b {}
	, bc {}
	, value {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

InputABCD::InputABCD(
		std::string dArg,
		InputA aArg,
		InputB bArg,
		std::vector<InputBC> bcArg,
		int valueArg) noexcept
	: d { std::move(dArg) }
	, a { std::move(aArg) }
	, b { std::move(bArg) }
	, bc { std::move(bcArg) }
	, value { std::move(valueArg) }
{
}

InputABCD::InputABCD(const InputABCD& other)
	: d { ModifiedVariable<std::string>::duplicate(other.d) }
	, a { ModifiedVariable<InputA>::duplicate(other.a) }
	, b { ModifiedVariable<InputB>::duplicate(other.b) }
	, bc { ModifiedVariable<InputBC>::duplicate<TypeModifier::List>(other.bc) }
	, value { ModifiedVariable<int>::duplicate(other.value) }
{
}

InputABCD::InputABCD(InputABCD&& other) noexcept
	: d { std::move(other.d) }
	, a { std::move(other.a) }
	, b { std::move(other.b) }
	, bc { std::move(other.bc) }
	, value { std::move(other.value) }
{
}

InputABCD::~InputABCD()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

InputABCD& InputABCD::operator=(const InputABCD& other)
{
	return *this = InputABCD { other };
}

InputABCD& InputABCD::operator=(InputABCD&& other) noexcept
{
	d = std::move(other.d);
	a = std::move(other.a);
	b = std::move(other.b);
	bc = std::move(other.bc);
	value = std::move(other.value);

	return *this;
}

InputBC::InputBC() noexcept
	: c {}
	, b {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

InputBC::InputBC(
		response::IdType cArg,
		InputB bArg) noexcept
	: c { std::move(cArg) }
	, b { std::move(bArg) }
{
}

InputBC::InputBC(const InputBC& other)
	: c { ModifiedVariable<response::IdType>::duplicate(other.c) }
	, b { ModifiedVariable<InputB>::duplicate(other.b) }
{
}

InputBC::InputBC(InputBC&& other) noexcept
	: c { std::move(other.c) }
	, b { std::move(other.b) }
{
}

InputBC::~InputBC()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

InputBC& InputBC::operator=(const InputBC& other)
{
	return *this = InputBC { other };
}

InputBC& InputBC::operator=(InputBC&& other) noexcept
{
	c = std::move(other.c);
	b = std::move(other.b);

	return *this;
}

} // namespace nestedinput

namespace client {

using namespace nestedinput;

template <>
response::Value Variable<InputA>::serialize(InputA&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(a)js"s, ModifiedVariable<bool>::serialize(std::move(inputValue.a)));

	return result;
}

template <>
response::Value Variable<InputB>::serialize(InputB&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(b)js"s, ModifiedVariable<double>::serialize(std::move(inputValue.b)));

	return result;
}

template <>
response::Value Variable<InputABCD>::serialize(InputABCD&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(d)js"s, ModifiedVariable<std::string>::serialize(std::move(inputValue.d)));
	result.emplace_back(R"js(a)js"s, ModifiedVariable<InputA>::serialize(std::move(inputValue.a)));
	result.emplace_back(R"js(b)js"s, ModifiedVariable<InputB>::serialize(std::move(inputValue.b)));
	result.emplace_back(R"js(bc)js"s, ModifiedVariable<InputBC>::serialize<TypeModifier::List>(std::move(inputValue.bc)));
	result.emplace_back(R"js(value)js"s, ModifiedVariable<int>::serialize(std::move(inputValue.value)));

	return result;
}

template <>
response::Value Variable<InputBC>::serialize(InputBC&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(c)js"s, ModifiedVariable<response::IdType>::serialize(std::move(inputValue.c)));
	result.emplace_back(R"js(b)js"s, ModifiedVariable<InputB>::serialize(std::move(inputValue.b)));

	return result;
}

template <>
graphql::nestedinput::client::query::testQuery::Response::control_Control::test_Output Response<graphql::nestedinput::client::query::testQuery::Response::control_Control::test_Output>::parse(response::Value&& response)
{
	graphql::nestedinput::client::query::testQuery::Response::control_Control::test_Output result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(id)js"sv)
			{
				result.id = ModifiedResponse<bool>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
graphql::nestedinput::client::query::testQuery::Response::control_Control Response<graphql::nestedinput::client::query::testQuery::Response::control_Control>::parse(response::Value&& response)
{
	graphql::nestedinput::client::query::testQuery::Response::control_Control result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(test)js"sv)
			{
				result.test = ModifiedResponse<graphql::nestedinput::client::query::testQuery::Response::control_Control::test_Output>::parse<TypeModifier::Nullable>(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

} // namespace client

namespace nestedinput::client::query::testQuery {

const std::string& GetOperationName() noexcept
{
	static const auto s_name = R"gql(testQuery)gql"s;

	return s_name;
}

response::Value serializeVariables(Variables&& variables)
{
	using namespace graphql::client;

	response::Value result { response::Type::Map };

	result.emplace_back(R"js(stream)js"s, ModifiedVariable<InputABCD>::serialize(std::move(variables.stream)));

	return result;
}

struct ResponseVisitor::impl
{
	enum class VisitorState
	{
		Start,
		Member_control,
		Member_control_test,
		Member_control_test_id,
		Complete,
	};

	VisitorState state { VisitorState::Start };
	Response response {};
};

ResponseVisitor::ResponseVisitor() noexcept
	: _pimpl { std::make_unique<impl>() }
{
}

ResponseVisitor::~ResponseVisitor()
{
}

void ResponseVisitor::add_value([[maybe_unused]] std::shared_ptr<const response::Value>&& value)
{
	using namespace graphql::client;

	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_control:
			_pimpl->state = impl::VisitorState::Start;
			_pimpl->response.control = ModifiedResponse<Response::control_Control>::parse(response::Value { *value });
			break;

		case impl::VisitorState::Member_control_test:
			_pimpl->state = impl::VisitorState::Member_control;
			_pimpl->response.control.test = ModifiedResponse<Response::control_Control::test_Output>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		case impl::VisitorState::Member_control_test_id:
			_pimpl->state = impl::VisitorState::Member_control_test;
			_pimpl->response.control.test->id = ModifiedResponse<bool>::parse<TypeModifier::Nullable>(response::Value { *value });
			break;

		default:
			break;
	}
}

void ResponseVisitor::reserve([[maybe_unused]] std::size_t count)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::start_object()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_control_test:
			_pimpl->response.control.test = std::make_optional<Response::control_Control::test_Output>({});
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_member([[maybe_unused]] std::string&& key)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Start:
			if (key == "control"sv)
			{
				_pimpl->state = impl::VisitorState::Member_control;
			}
			break;

		case impl::VisitorState::Member_control:
			if (key == "test"sv)
			{
				_pimpl->state = impl::VisitorState::Member_control_test;
			}
			break;

		case impl::VisitorState::Member_control_test:
			if (key == "id"sv)
			{
				_pimpl->state = impl::VisitorState::Member_control_test_id;
			}
			break;

		default:
			break;
	}
}

void ResponseVisitor::end_object()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_control_test:
			_pimpl->state = impl::VisitorState::Member_control;
			break;

		case impl::VisitorState::Member_control:
			_pimpl->state = impl::VisitorState::Start;
			break;

		default:
			break;
	}
}

void ResponseVisitor::start_array()
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::end_array()
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_null()
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_control_test:
			_pimpl->state = impl::VisitorState::Member_control;
			_pimpl->response.control.test = std::nullopt;
			break;

		case impl::VisitorState::Member_control_test_id:
			_pimpl->state = impl::VisitorState::Member_control_test;
			_pimpl->response.control.test->id = std::nullopt;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_string([[maybe_unused]] std::string&& value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_enum([[maybe_unused]] std::string&& value)
{
	using namespace graphql::client;

	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_id([[maybe_unused]] response::IdType&& value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_bool([[maybe_unused]] bool value)
{
	switch (_pimpl->state)
	{
		case impl::VisitorState::Member_control_test_id:
			_pimpl->state = impl::VisitorState::Member_control_test;
			_pimpl->response.control.test->id = value;
			break;

		default:
			break;
	}
}

void ResponseVisitor::add_int([[maybe_unused]] int value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::add_float([[maybe_unused]] double value)
{
	switch (_pimpl->state)
	{
		default:
			break;
	}
}

void ResponseVisitor::complete()
{
	_pimpl->state = impl::VisitorState::Complete;
}

Response ResponseVisitor::response()
{
	Response response {};

	switch (_pimpl->state)
	{
		case impl::VisitorState::Complete:
			_pimpl->state = impl::VisitorState::Start;
			std::swap(_pimpl->response, response);
			break;

		default:
			break;
	}

	return response;
}

Response parseResponse(response::Value&& response)
{
	using namespace graphql::client;

	Response result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(control)js"sv)
			{
				result.control = ModifiedResponse<query::testQuery::Response::control_Control>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetRequestText() noexcept
{
	return client::GetRequestText();
}

[[nodiscard("unnecessary call")]] const peg::ast& Traits::GetRequestObject() noexcept
{
	return client::GetRequestObject();
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetOperationName() noexcept
{
	return testQuery::GetOperationName();
}

[[nodiscard("unnecessary conversion")]] response::Value Traits::serializeVariables(Traits::Variables&& variables)
{
	return testQuery::serializeVariables(std::move(variables));
}

[[nodiscard("unnecessary conversion")]] Traits::Response Traits::parseResponse(response::Value&& response)
{
	return testQuery::parseResponse(std::move(response));
}

} // namespace nestedinput::client::query::testQuery
} // namespace graphql
