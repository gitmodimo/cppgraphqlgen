// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// WARNING! Do not edit this file manually, your changes will be overwritten.

#pragma once

#ifndef PROXYSCHEMA_H
#define PROXYSCHEMA_H

#include "graphqlservice/GraphQLResponse.h"
#include "graphqlservice/GraphQLService.h"

#include "graphqlservice/internal/Version.h"
#include "graphqlservice/internal/Schema.h"

#include <array>
#include <memory>
#include <string>
#include <string_view>

// Check if the library version is compatible with schemagen 5.0.0
static_assert(graphql::internal::MajorVersion == 5, "regenerate with schemagen: major version mismatch");
static_assert(graphql::internal::MinorVersion == 0, "regenerate with schemagen: minor version mismatch");

namespace graphql {
namespace proxy {

enum class [[nodiscard("unnecessary conversion")]] OperationType
{
	QUERY,
	MUTATION,
	SUBSCRIPTION
};

[[nodiscard("unnecessary call")]] constexpr auto getOperationTypeNames() noexcept
{
	using namespace std::literals;

	return std::array<std::string_view, 3> {
		R"gql(QUERY)gql"sv,
		R"gql(MUTATION)gql"sv,
		R"gql(SUBSCRIPTION)gql"sv
	};
}

[[nodiscard("unnecessary call")]] constexpr auto getOperationTypeValues() noexcept
{
	using namespace std::literals;

	return std::array<std::pair<std::string_view, OperationType>, 3> {
		std::make_pair(R"gql(QUERY)gql"sv, OperationType::QUERY),
		std::make_pair(R"gql(MUTATION)gql"sv, OperationType::MUTATION),
		std::make_pair(R"gql(SUBSCRIPTION)gql"sv, OperationType::SUBSCRIPTION)
	};
}

struct [[nodiscard("unnecessary construction")]] QueryInput
{
	explicit QueryInput() noexcept;
	explicit QueryInput(
		OperationType typeArg,
		std::string queryArg,
		std::optional<std::string> operationNameArg,
		std::optional<std::string> variablesArg) noexcept;
	QueryInput(const QueryInput& other);
	QueryInput(QueryInput&& other) noexcept;
	~QueryInput();

	QueryInput& operator=(const QueryInput& other);
	QueryInput& operator=(QueryInput&& other) noexcept;

	OperationType type;
	std::string query;
	std::optional<std::string> operationName;
	std::optional<std::string> variables;
};

namespace object {

class Query;
class QueryResults;

} // namespace object

class [[nodiscard("unnecessary construction")]] Operations final
	: public service::Request
{
public:
	explicit Operations(std::shared_ptr<object::Query> query);

	template <class TQuery>
	explicit Operations(std::shared_ptr<TQuery> query)
		: Operations {
			std::make_shared<object::Query>(std::move(query))
		}
	{
	}

private:
	std::shared_ptr<object::Query> _query;
};

void AddQueryDetails(const std::shared_ptr<schema::ObjectType>& typeQuery, const std::shared_ptr<schema::Schema>& schema);
void AddQueryResultsDetails(const std::shared_ptr<schema::ObjectType>& typeQueryResults, const std::shared_ptr<schema::Schema>& schema);

std::shared_ptr<schema::Schema> GetSchema();

} // namespace proxy
} // namespace graphql

#endif // PROXYSCHEMA_H
