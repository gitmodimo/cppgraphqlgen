// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// WARNING! Do not edit this file manually, your changes will be overwritten.

#pragma once

#ifndef PROXYCLIENT_H
#define PROXYCLIENT_H

#include "graphqlservice/GraphQLClient.h"
#include "graphqlservice/GraphQLParse.h"
#include "graphqlservice/GraphQLResponse.h"

#include "graphqlservice/internal/Version.h"

#include "ProxySharedTypes.h"

#include <optional>
#include <string>
#include <vector>

// Check if the library version is compatible with clientgen 5.0.0
static_assert(graphql::internal::MajorVersion == 5, "regenerate with clientgen: major version mismatch");
static_assert(graphql::internal::MinorVersion == 0, "regenerate with clientgen: minor version mismatch");

namespace graphql::proxy {

/// # Operation: query relayQuery
/// ```graphql
/// # Copyright (c) Microsoft Corporation. All rights reserved.
/// # Licensed under the MIT License.
/// 
/// query relayQuery($input: QueryInput!) {
///   relay(input: $input) {
///     data
///     errors
///   }
/// }
/// ```
namespace client {

// Return the original text of the request document.
[[nodiscard("unnecessary call")]] const std::string& GetRequestText() noexcept;

// Return a pre-parsed, pre-validated request object.
[[nodiscard("unnecessary call")]] const peg::ast& GetRequestObject() noexcept;

namespace query::relayQuery {

using graphql::proxy::client::GetRequestText;
using graphql::proxy::client::GetRequestObject;

// Return the name of this operation in the shared request document.
[[nodiscard("unnecessary call")]] const std::string& GetOperationName() noexcept;

using graphql::proxy::OperationType;

using graphql::proxy::QueryInput;

struct [[nodiscard("unnecessary construction")]] Variables
{
	QueryInput input {};
};

[[nodiscard("unnecessary conversion")]] response::Value serializeVariables(Variables&& variables);

struct [[nodiscard("unnecessary construction")]] Response
{
	struct [[nodiscard("unnecessary construction")]] relay_QueryResults
	{
		std::optional<std::string> data {};
		std::optional<std::vector<std::optional<std::string>>> errors {};
	};

	relay_QueryResults relay {};
};

class ResponseVisitor
	: public std::enable_shared_from_this<ResponseVisitor>
{
public:
	ResponseVisitor() noexcept;
	~ResponseVisitor();

	void add_value(std::shared_ptr<const response::Value>&&);
	void reserve(std::size_t count);
	void start_object();
	void add_member(std::string&& key);
	void end_object();
	void start_array();
	void end_array();
	void add_null();
	void add_string(std::string&& value);
	void add_enum(std::string&& value);
	void add_id(response::IdType&& value);
	void add_bool(bool value);
	void add_int(int value);
	void add_float(double value);
	void complete();

	Response response();

private:
	struct impl;

	std::unique_ptr<impl> _pimpl;
};

[[nodiscard("unnecessary conversion")]] Response parseResponse(response::Value&& response);

struct Traits
{
	[[nodiscard("unnecessary call")]] static const std::string& GetRequestText() noexcept;
	[[nodiscard("unnecessary call")]] static const peg::ast& GetRequestObject() noexcept;
	[[nodiscard("unnecessary call")]] static const std::string& GetOperationName() noexcept;

	using Variables = relayQuery::Variables;

	[[nodiscard("unnecessary conversion")]] static response::Value serializeVariables(Variables&& variables);

	using Response = relayQuery::Response;
	using ResponseVisitor = relayQuery::ResponseVisitor;

	[[nodiscard("unnecessary conversion")]] static Response parseResponse(response::Value&& response);
};

} // namespace query::relayQuery
} // namespace client
} // namespace graphql::proxy

#endif // PROXYCLIENT_H
